key=b"user-123"                 # already bytes
key="user-123".encode("utf-8")  # convert string to bytes

## Key Value in Partitions
ğŸ”¹ What happens under the hood

Kafkaâ€™s producer library takes your key.

Runs a hash function on it.

Does (hash(key) % number_of_partitions) â†’ decides the partition.

Sends the record there.

You donâ€™t need to create partitions manually for keys â€” as long as the topic has more than 1 partition, keys will get mapped.

If the topic has only 1 partition, then key or no key doesnâ€™t matter (everything goes to that one partition).


In the Java Kafka client (the standard one), Kafka uses Murmur2 hash (not Pythonâ€™s hash()).



hash_value = murmur2("user-123")    # e.g., produces 1123456789
partition = hash_value % 3
If:

murmur2("user-123") = 1123456789
then â†’ 1123456789 % 3 = 0 â†’ Partition 0.

If you send "user-123" again â†’ same Murmur2 hash â†’ still Partition 0.

But "user-456" might hash to something like 987654321, so â†’ 987654321 % 3 = 2.

4ï¸âƒ£ Why not Pythonâ€™s hash()?

Because Pythonâ€™s hash() is randomized per session (for security reasons, Python seeds its hash differently each process).
ğŸ‘‰ That means "user-123" could map to different partitions across runs if Pythonâ€™s hash() were used.

Thatâ€™s why Kafka fixed on Murmur2 â€” consistent across JVM, Python, Go, C++, etc.

Consumer in same group cannit read same partition
Consumer in different group can read same partition

Each consumer maintains the last processed message , in the event of crash it helps